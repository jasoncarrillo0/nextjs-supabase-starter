import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createMyServerClient } from "@/utils/supabase";
import { TABLES } from "@/utils/constants";
import { CoreUserFields, publicUserExists } from "@/utils/db-queries";


const log = console.log;


/*
    route purpose: user's email button contains a link as a GET request to this route, we defined in the signup-route.
                   

*/
export async function GET(request: Request) {
    const requestUrl = new URL(request.url);

    try {
        // The `/api/auth/confirm-user` route is required for the server-side auth flow implemented
        // by the ssr package. It exchanges an auth code for the user's session.
        // https://supabase.com/docs/guides/auth/auth-helpers/nextjs#managing-sign-in-with-code-exchange
        const code = requestUrl.searchParams.get("code");

  
        /*
            this code is generated by supabase and supabase put it inside the email confirm link button,
            and supabase knows this code came from itself. Without this code, there can be no authorization.
        */
        if (code) {
            log("\napi/auth/callback route triggered due to code: ", code);
            
            const cookieStore     = cookies();
            const supabase        = createMyServerClient(cookieStore);

            // supabase logs us in with it's code. if there's no error, the user is logged in according to supabase's management
            // of the auth.users table. We should never touch that table ourselves.
            const { error, data } = await supabase.auth.exchangeCodeForSession(code);

            
            if (error) {
                throw new Error(error.message);
            } else if (!data.user) {
                throw new Error("no user found when exchanging code for session.");
            }

            log("\n\nattempting to create user: ", data.user);
            log("with metadata (should have first and last name): ", data.user.user_metadata);
            
            
            // VERY IMPORTANT: ensure user doesn't exist in the public.users table. never remove this code
            const userExists = await publicUserExists(data.user.id);
            if (userExists) throw new Error("user already exists.");


            // create user instance
            const newUser: CoreUserFields = {
                email: data.user.email!,
                first_name: data.user.user_metadata.first_name, 
                last_name: data.user.user_metadata.last_name,
                id: data.user!.id,
                other_fields: {},
                acct_status: "confirmed"
            }

            /*
                below code assumes row level security is in place, to allow only authed users to insert a user into the public.users table we created,
                AND that no user currently exists in the public users table from above publicUserExists function. 
                it's too complicated to create a postgresql policy to do both these checks, so we just handle ensuring
                that the public user entry doesn't exist w/ code instead of a postgres policy
            */
            const dbRes = await supabase.from(TABLES.users).insert(newUser);
            log(dbRes);
            if (dbRes.error) {
                log(dbRes.error);
                throw new Error(dbRes.error.details);
            }


            log("successfully inserted user.");
        }


        log("Redirecting back to origin")
        return NextResponse.redirect(requestUrl.origin + "/home");

    } catch (e: any) {
        // URL to redirect to after sign in process completes
        log(e, e.message);

        return NextResponse.redirect(requestUrl.origin);
    }
}
